"use strict";

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _mongoose = _interopRequireDefault(require("mongoose"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Interface for data models. The default data layer uses an internal mongoose
 * model and is as such compatible with MongoDB.
 * @interface
 */
var BaseModel = /*#__PURE__*/function () {
  function BaseModel() {
    _classCallCheck(this, BaseModel);

    /** @const the underlying mongoose model used for queries */
    this.mongooseModel_ = this.createMongooseModel_();
  }
  /**
   * Returns the model schema. The child class must implement the static schema
   * property.
   * @return {string} the models schema
   */


  _createClass(BaseModel, [{
    key: "getSchema",
    value: function getSchema() {
      if (!this.constructor.schema) {
        throw new Error("Schema not defined");
      }

      return this.constructor.schema;
    }
    /**
     * Returns the model name. The child class must implement the static modelName
     * property.
     * @return {string} the name of the model
     */

  }, {
    key: "getModelName",
    value: function getModelName() {
      if (!this.constructor.modelName) {
        throw new Error("Every model must have a static modelName property");
      }

      return this.constructor.modelName;
    }
    /**
     * Returns the schema options defined in child class.
     * @return {object} the schema options
     */

  }, {
    key: "getSchemaOptions",
    value: function getSchemaOptions() {
      if (!this.constructor.schemaOptions) {
        return {};
      }

      return this.constructor.schemaOptions;
    }
    /**
     * @private
     * Creates a mongoose model based on schema, schema options and model name.
     * @return {Mongooose.Model} the mongoose model
     */

  }, {
    key: "createMongooseModel_",
    value: function createMongooseModel_() {
      var schema = this.getSchema();
      var options = this.getSchemaOptions();
      var mongooseSchema = new _mongoose["default"].Schema(schema, options);
      return _mongoose["default"].model(this.getModelName(), mongooseSchema);
    }
    /**
     */

  }, {
    key: "startSession",
    value: function startSession() {
      return this.mongooseModel_.startSession();
    }
    /**
     * Queries the mongoose model via the mongoose's findOne.
     * @param query {object} a mongoose selector query
     * @param options {?object=} mongoose options
     * @return {?mongoose.Document} the retreived mongoose document or null.
     */

  }, {
    key: "findOne",
    value: function findOne(query) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.mongooseModel_.findOne(query, options).lean();
    }
    /**
     * Queries the mongoose model via the mongoose's find.
     * @param query {object} a mongoose selector query
     * @param options {?object=} mongoose options
     * @return {Array<mongoose.Document>} the retreived mongoose documents or
     * an empty array
     */

  }, {
    key: "find",
    value: function find(query, options, offset, limit) {
      return this.mongooseModel_.find(query, options).skip(offset).limit(limit).lean();
    }
  }, {
    key: "count",
    value: function count() {
      return this.mongooseModel_.count({});
    }
    /**
     * Update a model via the mongoose model's updateOne.
     * @param query {object} a mongoose selector query
     * @param update {object} mongoose update object
     * @param options {?object=} mongoose options
     * @return {object} mongoose result
     */

  }, {
    key: "updateOne",
    value: function updateOne(query, update) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      options["new"] = true;
      return this.mongooseModel_.findOneAndUpdate(query, update, options).lean();
    }
    /**
     * Update a model via the mongoose model's update.
     * @param query {object} a mongoose selector query
     * @param update {object} mongoose update object
     * @param options {?object=} mongoose options
     * @return {object} mongoose result
     */

  }, {
    key: "update",
    value: function update(query, _update, options) {
      return this.mongooseModel_.update(query, _update, options);
    }
    /**
     * Creates a document in the mongoose model's collection via create.
     * @param object {object} the value of the document to be created
     * @param options {?object=} mongoose options
     * @return {object} mongoose result
     */

  }, {
    key: "create",
    value: function create(object, options) {
      return this.mongooseModel_.create(object, options);
    }
    /**
     * Deletes a document in the mongoose model's collection
     * @param query {object} the value of the document to be created
     * @param options {?object=} mongoose options
     * @return {object} mongoose result
     */

  }, {
    key: "deleteOne",
    value: function deleteOne(query, options) {
      return this.mongooseModel_.deleteOne(query, options);
    }
    /**
     * Deletes many document in the mongoose model's collection
     * @param query {object} the value of the document to be created
     * @param options {?object=} mongoose options
     * @return {object} mongoose result
     */

  }, {
    key: "delete",
    value: function _delete(query, options) {
      return this.mongooseModel_.deleteMany(query, options);
    }
  }]);

  return BaseModel;
}();

var _default = BaseModel;
exports["default"] = _default;